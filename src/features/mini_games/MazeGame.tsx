"use client";

import React, {
  useEffect,
  useMemo,
  useRef,
  useState,
  useCallback,
} from "react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { cn } from "@/lib/utils";
import { toast } from "sonner";
import { DoorOpen, Timer, MoveUpRight, Skull, Trophy } from "lucide-react";

/** MiniGameDef Í∞ÄÏ†ï:
 * export type MiniGameDef = {
 *  id: string;
 *  title: string;
 *  icon: React.ReactNode;
 *  entryFee: number;
 *  howTo: string | React.ReactNode;
 *  Component: React.FC<{ onExit: () => void }>;
 * }
 */

const CELL_WALL = 1;
const CELL_PATH = 0;

type Point = { r: number; c: number };
type FPoint = { x: number; y: number }; // ÌîΩÏÖÄ Ï¢åÌëú

type Collectible = {
  r: number;
  c: number;
  kind: "potato" | "gold";
  taken?: boolean;
};

type Monster = {
  // px Îã®ÏúÑ ÏúÑÏπòÎ°ú Î≥ÄÍ≤Ω
  x: number;
  y: number;
  vx: number; // -1,0,1 (Î∞©Ìñ•)
  vy: number;
  speedPx: number; // px/sec
};

function randomShuffle<T>(arr: T[]) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = (Math.random() * (i + 1)) | 0;
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function randInt(min: number, max: number) {
  return (Math.random() * (max - min + 1) + min) | 0;
}
function clamp(v: number, lo: number, hi: number) {
  return Math.max(lo, Math.min(hi, v));
}
function easeOutCubic(t: number) {
  return 1 - Math.pow(1 - t, 3);
}

const THEME = {
  wall: "#262637",
  floor: "#fbfbff",
  start: "#8bd3dd",
  exit: "#ffd166",
  player: "#7c3aed",
  gridAccent: "#ededf6",
  coin: "#f59e0b",
  potato: "#a16207",
  danger: "#ef4444",
};

const DEFAULT_TIME = 60;
const ENTRY_FEE = 25;

// Ïù¥Îèô Î≥¥Í∞Ñ(Ìïú Ïπ∏) ÏãúÍ∞Ñ
const MOVE_DURATION = 210; // ms (ÎäêÏä® + easing)

function drawEmoji(
  ctx: CanvasRenderingContext2D,
  emoji: string,
  x: number,
  y: number,
  fontSize: number
) {
  ctx.font = `${fontSize}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(emoji, x, y);
}

function generateMaze(rows: number, cols: number) {
  if (rows % 2 === 0) rows += 1;
  if (cols % 2 === 0) cols += 1;

  const grid = Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => CELL_WALL)
  );

  const stack: Point[] = [];
  const start: Point = { r: 1, c: 1 };
  grid[start.r][start.c] = CELL_PATH;
  stack.push(start);

  const dirs = [
    { dr: -2, dc: 0 },
    { dr: 2, dc: 0 },
    { dr: 0, dc: -2 },
    { dr: 0, dc: 2 },
  ];

  while (stack.length) {
    const cur = stack[stack.length - 1];
    const shuffled = randomShuffle(dirs.slice());
    let carved = false;

    for (const { dr, dc } of shuffled) {
      const nr = cur.r + dr;
      const nc = cur.c + dc;
      if (nr > 0 && nr < rows - 1 && nc > 0 && nc < cols - 1) {
        if (grid[nr][nc] === CELL_WALL) {
          grid[cur.r + dr / 2][cur.c + dc / 2] = CELL_PATH;
          grid[nr][nc] = CELL_PATH;
          stack.push({ r: nr, c: nc });
          carved = true;
          break;
        }
      }
    }
    if (!carved) stack.pop();
  }

  // Ï∂úÍµ¨: Ïö∞ÌïòÎã® PATH
  let exit: Point = { r: rows - 2, c: cols - 2 };
  outer: for (let rr = rows - 2; rr >= rows - 8 && rr >= 1; rr--) {
    for (let cc = cols - 2; cc >= cols - 8 && cc >= 1; cc--) {
      if (grid[rr][cc] === CELL_PATH) {
        exit = { r: rr, c: cc };
        break outer;
      }
    }
  }

  return { grid, start, exit, rows, cols };
}

function placeCollectibles(
  grid: number[][],
  start: Point,
  exit: Point,
  countPotato: number,
  countGold: number
): Collectible[] {
  const rows = grid.length;
  const cols = grid[0].length;
  const cells: Point[] = [];
  for (let r = 1; r < rows - 1; r++) {
    for (let c = 1; c < cols - 1; c++) {
      if (grid[r][c] === CELL_PATH) cells.push({ r, c });
    }
  }
  randomShuffle(cells);

  const tooClose = (a: Point, b: Point) =>
    Math.abs(a.r - b.r) + Math.abs(a.c - b.c) < 4;

  const res: Collectible[] = [];
  for (const kind of ["potato", "gold"] as const) {
    const need = kind === "potato" ? countPotato : countGold;
    let i = 0;
    for (const cell of cells) {
      if (i >= need) break;
      if (tooClose(cell, start) || tooClose(cell, exit)) continue;
      if (res.some((x) => x.r === cell.r && x.c === cell.c)) continue;
      res.push({ r: cell.r, c: cell.c, kind });
      i++;
    }
  }
  return res;
}

function placeMonstersPx(
  grid: number[][],
  count: number,
  cellSize: number
): Monster[] {
  const rows = grid.length;
  const cols = grid[0].length;
  const list: Monster[] = [];
  let tries = 0;

  while (list.length < count && tries++ < 5000) {
    const r = randInt(2, rows - 3);
    const c = randInt(2, cols - 3);
    if (grid[r][c] !== CELL_PATH) continue;

    // Í∞ÄÎä•Ìïú Î∞©Ìñ•
    const dirs: Array<{ vx: number; vy: number }> = [];
    if (grid[r - 1]?.[c] === CELL_PATH) dirs.push({ vx: 0, vy: -1 });
    if (grid[r + 1]?.[c] === CELL_PATH) dirs.push({ vx: 0, vy: 1 });
    if (grid[r]?.[c - 1] === CELL_PATH) dirs.push({ vx: -1, vy: 0 });
    if (grid[r]?.[c + 1] === CELL_PATH) dirs.push({ vx: 1, vy: 0 });
    if (!dirs.length) continue;

    const { vx, vy } = dirs[(Math.random() * dirs.length) | 0];

    const cx = c * cellSize + cellSize / 2;
    const cy = r * cellSize + cellSize / 2;
    // üîª ÏÜçÎèÑ ÎåÄÌè≠ ÌïòÌñ• (cells/sec ‚Üí px/sec)
    const cellsPerSec = 0.7 + Math.random() * 0.5; // 0.7 ~ 1.2
    const speedPx = cellsPerSec * cellSize;

    list.push({ x: cx, y: cy, vx, vy, speedPx });
  }
  return list;
}

function drawMaze(
  ctx: CanvasRenderingContext2D,
  grid: number[][],
  cellSize: number,
  playerPx: FPoint,
  start: Point,
  exit: Point,
  w: number,
  h: number,
  collectibles: Collectible[],
  monsters: Monster[]
) {
  ctx.clearRect(0, 0, w, h);

  // Î∞îÌÉï
  ctx.fillStyle = THEME.floor;
  ctx.fillRect(0, 0, w, h);

  const rows = grid.length;
  const cols = grid[0].length;

  // Í≤©Ïûê
  ctx.strokeStyle = THEME.gridAccent;
  ctx.lineWidth = 1;
  for (let r = 0; r <= rows; r++) {
    ctx.beginPath();
    ctx.moveTo(0, r * cellSize + 0.5);
    ctx.lineTo(cols * cellSize, r * cellSize + 0.5);
    ctx.stroke();
  }
  for (let c = 0; c <= cols; c++) {
    ctx.beginPath();
    ctx.moveTo(c * cellSize + 0.5, 0);
    ctx.lineTo(c * cellSize + 0.5, rows * cellSize);
    ctx.stroke();
  }

  // Î≤Ω
  ctx.fillStyle = THEME.wall;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (grid[r][c] === CELL_WALL) {
        ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
      }
    }
  }

  // ÏãúÏûë/Ï∂úÍµ¨
  ctx.fillStyle = THEME.start;
  ctx.fillRect(
    start.c * cellSize + 2,
    start.r * cellSize + 2,
    cellSize - 4,
    cellSize - 4
  );

  ctx.fillStyle = THEME.exit;
  ctx.fillRect(
    exit.c * cellSize + 2,
    exit.r * cellSize + 2,
    cellSize - 4,
    cellSize - 4
  );

  // ÏïÑÏù¥ÌÖú
  for (const it of collectibles) {
    if (it.taken) continue;
    const cx = it.c * cellSize + cellSize / 2;
    const cy = it.r * cellSize + cellSize / 2;
    const fs = Math.min(cellSize * 0.9, 28);
    drawEmoji(ctx, it.kind === "potato" ? "ü•î" : "ü™ô", cx, cy, fs);
  }

  // Î™¨Ïä§ÌÑ∞
  for (const m of monsters) {
    const fs = Math.min(cellSize * 0.95, 32);
    drawEmoji(ctx, "üî•", m.x, m.y, fs);
  }

  // ÌîåÎ†àÏù¥Ïñ¥
  ctx.beginPath();
  ctx.fillStyle = THEME.player;
  ctx.arc(
    playerPx.x,
    playerPx.y,
    Math.min(10, cellSize * 0.35),
    0,
    Math.PI * 2
  );
  ctx.fill();
}

/** Ïä§ÏôÄÏù¥ÌîÑ ‚Üí Î∞©Ìñ• */
function useSwipe(onDir: (d: "up" | "down" | "left" | "right") => void) {
  const startRef = useRef<{ x: number; y: number } | null>(null);
  useEffect(() => {
    const onTouchStart = (e: TouchEvent) => {
      const t = e.changedTouches[0];
      startRef.current = { x: t.clientX, y: t.clientY };
    };
    const onTouchEnd = (e: TouchEvent) => {
      if (!startRef.current) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - startRef.current.x;
      const dy = t.clientY - startRef.current.y;
      const ax = Math.abs(dx);
      const ay = Math.abs(dy);
      if (Math.max(ax, ay) < 24) return;
      if (ax > ay) onDir(dx > 0 ? "right" : "left");
      else onDir(dy > 0 ? "down" : "up");
      startRef.current = null;
    };
    window.addEventListener("touchstart", onTouchStart, { passive: true });
    window.addEventListener("touchend", onTouchEnd);
    return () => {
      window.removeEventListener("touchstart", onTouchStart);
      window.removeEventListener("touchend", onTouchEnd);
    };
  }, [onDir]);
}

const MazeComponent: React.FC<{ onExit: () => void }> = ({ onExit }) => {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  // ‚ñ∂ ÎØ∏Î°ú ÌÅ¨Í∏∞ ÌôïÎåÄ (ÌôîÎ©¥ ÎÑìÏùÑÏàòÎ°ù ÌÅ¨Í≤å)
  const [canvasSize, setCanvasSize] = useState({ w: 840, h: 640 });
  const { rows, cols } = useMemo(() => {
    const w = canvasSize.w;
    const baseCols = w < 560 ? 31 : w < 800 ? 37 : 41;
    const baseRows = w < 560 ? 27 : w < 800 ? 31 : 35;
    return { rows: baseRows | 1, cols: baseCols | 1 };
  }, [canvasSize.w]);

  const [seed, setSeed] = useState(0);
  const { grid, start, exit } = useMemo(
    () => generateMaze(rows, cols),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [rows, cols, seed]
  );

  // Î†åÎçî ÌÅ¨Í∏∞
  const cellSize = useMemo(() => {
    const s1 = Math.floor(canvasSize.w / cols);
    const s2 = Math.floor(canvasSize.h / rows);
    return Math.max(12, Math.min(s1, s2));
  }, [canvasSize, rows, cols]);

  const drawnSize = useMemo(
    () => ({ w: cols * cellSize, h: rows * cellSize }),
    [cols, rows, cellSize]
  );

  // ===== Í≤åÏûÑ Îü¨Îãù ÏÉÅÌÉú(React state: HUDÎßå) =====
  const [state, setState] = useState<"ready" | "playing" | "clear" | "fail">(
    "ready"
  );
  const [timeLeft, setTimeLeft] = useState<number>(DEFAULT_TIME);
  const [potatoes, setPotatoes] = useState(0);
  const [gold, setGold] = useState(0);

  // ===== ÎÇ¥Î∂Ä Í≤åÏûÑ Ïò§Î∏åÏ†ùÌä∏ (useRefÎ°ú Î≥¥Í¥Ä) =====
  const playerCellRef = useRef<Point>({ ...start });
  const targetCellRef = useRef<Point>({ ...start });
  const playerPxRef = useRef<FPoint>({
    x: start.c * cellSize + cellSize / 2,
    y: start.r * cellSize + cellSize / 2,
  });

  const collectiblesRef = useRef<Collectible[]>(
    placeCollectibles(grid, start, exit, 8, 6)
  );
  const monstersRef = useRef<Monster[]>(placeMonstersPx(grid, 4, cellSize)); // ÏàòÎüâ ÏÇ¥Ïßù Í∞êÏÜå

  // Ïù¥Îèô Î≥¥Í∞Ñ ÌÉÄÏù¥Î∞ç
  const moveFromRef = useRef<FPoint>({ ...playerPxRef.current });
  const moveToRef = useRef<FPoint>({ ...playerPxRef.current });
  const moveStartRef = useRef<number>(0);

  // Î¶¨ÏÇ¨Ïù¥Ï¶à
  useEffect(() => {
    const resize = () => {
      if (!containerRef.current) return;
      const rect = containerRef.current.getBoundingClientRect();
      const w = clamp(Math.floor(rect.width), 420, 1100);
      const h = Math.floor((w * 3) / 4);
      setCanvasSize({ w, h });
    };
    resize();
    const ro = new ResizeObserver(resize);
    if (containerRef.current) ro.observe(containerRef.current);
    return () => ro.disconnect();
  }, []);

  // grid/seed Î∞îÎÄåÎ©¥ ref Ïû¨Î∞∞Ïπò
  useEffect(() => {
    collectiblesRef.current = placeCollectibles(grid, start, exit, 8, 6);
    monstersRef.current = placeMonstersPx(grid, 4, cellSize);
    // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπòÎèÑ Ïû¨ÏÑ§Ï†ï
    playerCellRef.current = { ...start };
    targetCellRef.current = { ...start };
    const px = {
      x: start.c * cellSize + cellSize / 2,
      y: start.r * cellSize + cellSize / 2,
    };
    playerPxRef.current = px;
    moveFromRef.current = px;
    moveToRef.current = px;
    moveStartRef.current = performance.now();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [grid, cellSize, seed]);

  // ÌÉÄÏù¥Î®∏ (HUDÎßå setState)
  useEffect(() => {
    if (state !== "playing") return;
    const id = window.setInterval(() => {
      setTimeLeft((t) => {
        if (t <= 1) {
          window.clearInterval(id);
          setState("fail");
          toast.error("ÏãúÍ∞Ñ Ï¥àÍ≥º! Îã§ÏùåÏóê Îã§Ïãú ÎèÑÏ†ÑÌï¥Î¥êÏöî üïí");
          return 0;
        }
        return t - 1;
      });
    }, 1000);
    return () => window.clearInterval(id);
  }, [state]);

  // ÏûÖÎ†•ÏùÄ ‚ÄúÌïú Î≤àÏóê Ìïú Ïπ∏‚Äù ÌÅê
  const tryStep = useCallback(
    (dir: "up" | "down" | "left" | "right") => {
      if (state !== "playing") return;

      // ÌòÑÏû¨ Î≥¥Í∞Ñ Ï§ëÏù¥Î©¥ Î¨¥Ïãú(ÌÅ¥ÎûòÏãù ÌÉÄÏùºÍ∞ê)
      const now = performance.now();
      const t = clamp((now - moveStartRef.current) / MOVE_DURATION, 0, 1);
      if (t < 1) return;

      const d = { up: [-1, 0], down: [1, 0], left: [0, -1], right: [0, 1] }[
        dir
      ]!;
      const cur = playerCellRef.current;
      const nr = cur.r + d[0];
      const nc = cur.c + d[1];
      if (
        nr >= 0 &&
        nr < grid.length &&
        nc >= 0 &&
        nc < grid[0].length &&
        grid[nr][nc] === CELL_PATH
      ) {
        // ÏÖÄ Ïù¥Îèô ÌóàÏö© ‚Üí Î≥¥Í∞Ñ ÏãúÏûë
        const to = {
          x: nc * cellSize + cellSize / 2,
          y: nr * cellSize + cellSize / 2,
        };
        moveFromRef.current = { ...playerPxRef.current };
        moveToRef.current = to;
        moveStartRef.current = now;
        playerCellRef.current = { r: nr, c: nc };
        targetCellRef.current = { r: nr, c: nc };
      }
    },
    [state, grid, cellSize]
  );

  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      const k = e.key.toLowerCase();
      let dir: "up" | "down" | "left" | "right" | null = null;
      if (k === "arrowup" || k === "w") dir = "up";
      else if (k === "arrowdown" || k === "s") dir = "down";
      else if (k === "arrowleft" || k === "a") dir = "left";
      else if (k === "arrowright" || k === "d") dir = "right";
      if (!dir) return;
      e.preventDefault();
      tryStep(dir);
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [tryStep]);

  useSwipe((d) => tryStep(d));

  // ===== rAF Î£®ÌîÑ (Ïò§ÏßÅ Î¨ºÎ¶¨/Í∑∏Î¶¨Í∏∞; React setStateÎäî Ïù¥Î≤§Ìä∏ ÎïåÎßå) =====
  useEffect(() => {
    if (state !== "playing" && state !== "ready") return;

    const cvs = canvasRef.current;
    if (!cvs) return;
    const ctx = cvs.getContext("2d");
    if (!ctx) return;

    let rafId = 0;
    let last = performance.now();

    const tick = (now: number) => {
      const dt = Math.min((now - last) / 1000, 0.05); // clamp 50ms
      last = now;

      // ÌîåÎ†àÏù¥Ïñ¥ Î≥¥Í∞Ñ
      const t = clamp((now - moveStartRef.current) / MOVE_DURATION, 0, 1);
      const k = easeOutCubic(t);
      const from = moveFromRef.current;
      const to = moveToRef.current;
      playerPxRef.current = {
        x: from.x + (to.x - from.x) * k,
        y: from.y + (to.y - from.y) * k,
      };

      // ÏàòÏßëÌíà ÌîΩÏóÖ (ÏÖÄ indexÎäî floorÎ°ú ÏïàÏ†ïÌôî)
      const cc = Math.floor(playerPxRef.current.x / cellSize);
      const rr = Math.floor(playerPxRef.current.y / cellSize);
      for (const it of collectiblesRef.current) {
        if (!it.taken && it.r === rr && it.c === cc) {
          it.taken = true;
          if (it.kind === "potato") {
            setPotatoes((p) => p + 1);
            toast.success("ü•î Í∞êÏûê +1");
          } else {
            setGold((g) => g + 5);
            toast.success("ü™ô Í≥®Îìú +5");
          }
        }
      }

      // Î™¨Ïä§ÌÑ∞ Ïù¥Îèô (px Îã®ÏúÑ)
      for (const m of monstersRef.current) {
        let nx = m.x + m.vx * m.speedPx * dt;
        let ny = m.y + m.vy * m.speedPx * dt;

        // Î≤Ω Î∞òÏÇ¨ Ï≤¥ÌÅ¨: Îã§Ïùå ÏúÑÏπòÏùò ÏÖÄÏùÑ Î≥∏Îã§
        const nextC = Math.floor(nx / cellSize);
        const nextR = Math.floor(ny / cellSize);
        if (
          nextR < 0 ||
          nextR >= grid.length ||
          nextC < 0 ||
          nextC >= grid[0].length ||
          grid[nextR][nextC] === CELL_WALL
        ) {
          // ÏßÑÌñâ Î∞©Ìñ•ÏùÑ Î∞òÏ†Ñ
          m.vx = -m.vx;
          m.vy = -m.vy;
          // Î∞òÏ†Ñ ÌõÑ Îã§Ïãú Ïù¥Îèô
          nx = m.x + m.vx * m.speedPx * dt;
          ny = m.y + m.vy * m.speedPx * dt;
        }
        m.x = nx;
        m.y = ny;
      }

      // Ï∂©Îèå ÌåêÏ†ï (px Ïõê Ï∂©Îèå)
      const pr = playerPxRef.current;
      const playerR = Math.min(cellSize * 0.33, 9);
      const monsterR = Math.min(cellSize * 0.33, 9);
      let dead = false;
      for (const m of monstersRef.current) {
        const dist = Math.hypot(m.x - pr.x, m.y - pr.y);
        if (dist < playerR + monsterR) {
          dead = true;
          break;
        }
      }
      if (dead && state === "playing") {
        setState("fail");
        toast.error("üî• Î∂à Î™¨Ïä§ÌÑ∞ÏóêÍ≤å Î∂àÌÉÄÏ£ΩÏóàÏñ¥Ïöî...");
      }

      // Ï∂úÍµ¨ ÎèÑÏ∞© (ÏÖÄ Í∏∞Ï§Ä)
      if (state === "playing") {
        const pc = Math.floor(pr.x / cellSize);
        const rr2 = Math.floor(pr.y / cellSize);
        if (rr2 === exit.r && pc === exit.c) {
          setState("clear");
          setGold((g) => g + 30);
          toast.success("üéâ ÌÉàÏ∂ú ÏÑ±Í≥µ! Î≥¥ÏÉÅ: Í≥®Îìú +30", {
            icon: <Trophy className="h-4 w-4 text-yellow-500" />,
          });
        }
      }

      // Î†åÎçî
      drawMaze(
        ctx,
        grid,
        cellSize,
        playerPxRef.current,
        start,
        exit,
        drawnSize.w,
        drawnSize.h,
        collectiblesRef.current,
        monstersRef.current
      );

      rafId = requestAnimationFrame(tick);
    };

    rafId = requestAnimationFrame((t) => {
      last = t;
      requestAnimationFrame(tick);
    });
    return () => cancelAnimationFrame(rafId);
  }, [state, grid, cellSize, start, exit, drawnSize]);

  // Ï¥àÍ∏∞ ÌéòÏù∏Ìä∏(ÎåÄÍ∏∞ÌôîÎ©¥)
  useEffect(() => {
    const cvs = canvasRef.current;
    if (!cvs) return;
    const ctx = cvs.getContext("2d");
    if (!ctx) return;
    drawMaze(
      ctx,
      grid,
      cellSize,
      {
        x: start.c * cellSize + cellSize / 2,
        y: start.r * cellSize + cellSize / 2,
      },
      start,
      exit,
      drawnSize.w,
      drawnSize.h,
      collectiblesRef.current,
      monstersRef.current
    );
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [grid, cellSize, start, exit, drawnSize]);

  // Ïª®Ìä∏Î°§
  const startGame = () => {
    setPotatoes(0);
    setGold(0);
    setTimeLeft(DEFAULT_TIME);
    setState("playing");

    // Î≥¥Í∞Ñ Î¶¨ÏÖã
    playerCellRef.current = { ...start };
    targetCellRef.current = { ...start };
    const px = {
      x: start.c * cellSize + cellSize / 2,
      y: start.r * cellSize + cellSize / 2,
    };
    playerPxRef.current = px;
    moveFromRef.current = px;
    moveToRef.current = px;
    moveStartRef.current = performance.now();
  };

  const retry = () => {
    setSeed((s) => s + 1); // ÏÉàÎ°úÏö¥ ÎØ∏Î°ú
    collectiblesRef.current = placeCollectibles(grid, start, exit, 8, 6);
    monstersRef.current = placeMonstersPx(grid, 4, cellSize);
    startGame();
  };

  const quit = () => {
    onExit();
    if (state === "clear" || potatoes > 0 || gold > 0) {
      toast.message("ÎØ∏Î°ú Í≤∞Í≥º", {
        description: `ü•î ${potatoes}Í∞ú, ü™ô ${gold}Í≥®Îìú`,
      });
    }
  };

  const progress = Math.max(0, Math.min(100, (timeLeft / DEFAULT_TIME) * 100));

  return (
    <div className="w-full">
      {/* ÏÉÅÎã® HUD */}
      <div className="mb-3 flex flex-wrap items-center justify-between gap-3">
        <div className="flex items-center gap-3">
          <Badge variant="secondary" className="gap-2">
            <Timer className="h-4 w-4" />
            ÎÇ®ÏùÄ ÏãúÍ∞Ñ:{" "}
            <b className={cn(timeLeft <= 10 && "text-red-600")}>{timeLeft}s</b>
          </Badge>
          <div
            className="h-2 w-44 rounded-full bg-muted overflow-hidden"
            aria-label="time gauge"
            title="ÎÇ®ÏùÄ ÏãúÍ∞Ñ"
          >
            <div
              className={cn(
                "h-full transition-[width] duration-300",
                progress < 25
                  ? "bg-red-500"
                  : progress < 50
                  ? "bg-yellow-500"
                  : "bg-emerald-500"
              )}
              style={{ width: `${progress}%` }}
            />
          </div>

          <Badge variant="outline" className="gap-1">
            ü•î {potatoes}
          </Badge>
          <Badge variant="outline" className="gap-1">
            ü™ô {gold}
          </Badge>
        </div>

        <div className="flex items-center gap-2">
          {state === "ready" && (
            <Button size="sm" onClick={startGame} className="gap-2">
              <MoveUpRight className="h-4 w-4" />
              ÏãúÏûë
            </Button>
          )}
          {state === "playing" && (
            <>
              <Button size="sm" variant="outline" onClick={retry}>
                Î¶¨ÏÖã(ÏÉà ÎØ∏Î°ú)
              </Button>
              <Button
                size="sm"
                variant="secondary"
                onClick={quit}
                className="gap-2"
              >
                <DoorOpen className="h-4 w-4" />
                Ìè¨Í∏∞
              </Button>
            </>
          )}
          {state === "clear" && (
            <>
              <Button size="sm" onClick={retry}>
                Îã§ÏãúÌïòÍ∏∞
              </Button>
              <Button size="sm" variant="secondary" onClick={quit}>
                ÎÇòÍ∞ÄÍ∏∞
              </Button>
            </>
          )}
          {state === "fail" && (
            <>
              <Button size="sm" onClick={retry} className="gap-2">
                <Skull className="h-4 w-4" />
                Îã§ÏãúÌïòÍ∏∞
              </Button>
              <Button size="sm" variant="secondary" onClick={quit}>
                ÎÇòÍ∞ÄÍ∏∞
              </Button>
            </>
          )}
        </div>
      </div>

      {/* ÌîåÎ†àÏù¥ ÏòÅÏó≠ */}
      <div ref={containerRef} className="w-full grid place-items-center">
        <canvas
          ref={canvasRef}
          width={drawnSize.w}
          height={drawnSize.h}
          className="rounded-2xl ring-1 ring-slate-200 bg-white touch-none max-w-full"
          style={{ imageRendering: "pixelated" }}
          aria-label="ÎØ∏Î°ú Í≤åÏûÑ Î≥¥Îìú"
        />
      </div>

      <div className="mt-3 text-xs text-muted-foreground text-center leading-relaxed">
        Ï°∞Ïûë: <b>WASD/ÌôîÏÇ¥Ìëú</b> ÎòêÎäî <b>Ïä§ÏôÄÏù¥ÌîÑ</b> ‚Ä¢ ÏïÑÏù¥ÌÖú:{" "}
        <b>ü•î +1, ü™ô +5</b> ‚Ä¢ Ï∂úÍµ¨ Î≥¥ÏÉÅ: <b>ü™ô +30</b> ‚Ä¢ Î™¨Ïä§ÌÑ∞:{" "}
        <b>üî• ÎãøÏúºÎ©¥ Ï¶âÏãú ÏÇ¨Îßù</b>
      </div>
    </div>
  );
};

export const mazeMeta = {
  id: "maze_escape",
  title: "ÎØ∏Î°ú ÌÉàÏ∂ú",
  icon: "üåÄ",
  entryFee: ENTRY_FEE,
  howTo: [
    "Ï†úÌïú ÏãúÍ∞Ñ ÎÇ¥ ÏãúÏûëÏ†ê(ÌïòÎäòÏÉâ)ÏóêÏÑú Ï∂úÍµ¨(ÎÖ∏ÎûÄÏÉâ)ÍπåÏßÄ Ïù¥ÎèôÌïòÏÑ∏Ïöî.",
    "Ï°∞Ïûë: WASD/ÌôîÏÇ¥ÌëúÌÇ§ ¬∑ Î™®Î∞îÏùº Ïä§ÏôÄÏù¥ÌîÑ.",
    "ÏïÑÏù¥ÌÖú: ü•î=+1, ü™ô=+5. Ï∂úÍµ¨ ÎèÑÏ∞© Ïãú ü™ô+30.",
    "üî• Î™¨Ïä§ÌÑ∞Ïóê ÎãøÏúºÎ©¥ Ï¶âÏÇ¨Ìï©ÎãàÎã§.",
  ].join("\n"),
  Component: MazeComponent,
} satisfies import("@/features/mini_games/RecipeMemoryGame").MiniGameDef;
